<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>查询数据 - HashData</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "查询数据";
    var mkdocs_page_input_path = "management/management-quering-data.md";
    var mkdocs_page_url = "/management/management-quering-data/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> HashData</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">欢迎使用</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../overview/"><&product-name> 系统概述</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span><&product-name> 管理介绍</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../management-accessing-database/">访问数据库</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../management-defining-database-objects/">定义数据库对象</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../management-managing-data/">数据管理</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">查询数据</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#_1">查询数据</a></li>
                
                    <li><a class="toctree-l4" href="#_2">数据处理简介</a></li>
                
            
                <li class="toctree-l3"><a href="#todo-pic">TODO pic</a></li>
                
            
                <li class="toctree-l3"><a href="#todo-pic_1">TODO pic</a></li>
                
                    <li><a class="toctree-l4" href="#_4">理解查询计划</a></li>
                
            
                <li class="toctree-l3"><a href="#todo-pic_2">TODO pic</a></li>
                
                    <li><a class="toctree-l4" href="#_5">理解并行查询计划的执行</a></li>
                
            
                <li class="toctree-l3"><a href="#todo-pic_3">TODO pic</a></li>
                
                    <li><a class="toctree-l4" href="#_6">查询的定义</a></li>
                
                    <li><a class="toctree-l4" href="#_22">使用函数和运算符</a></li>
                
            
                <li class="toctree-l3"><a href="#todo">TODO</a></li>
                
            
            </ul>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>SQL命令参考</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../sql-ref/">SQL命令参考</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../sql-ref/sql-ref-summary/">列表</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>系统表参考</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../meta-ref/">系统表参考</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../meta-ref/meta-ref-all/">系统表</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../history/">文档历史</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">HashData</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li><&product-name> 管理介绍 &raquo;</li>
        
      
    
    <li>查询数据</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="_1">查询数据</h2>
<p>本章节想您介绍使用 SQL 的相关信息。
This topic provides information about using SQL in Greenplum databases.
You enter SQL statements called queries to view, change, and analyze data in a database using the psql interactive SQL client and other client tools.</p>
<ul>
<li>About Greenplum Query Processing</li>
<li>About the Pivotal Query Optimizer</li>
<li>Defining Queries</li>
<li>Using Functions and Operators</li>
<li>Query Performance</li>
<li>Managing Spill Files Generated by Queries</li>
<li>Query Profiling</li>
</ul>
<h3 id="_2">数据处理简介</h3>
<p>本主题为您介绍 &lt;&amp;product-name&gt; 是如何处理查询请求的。理解查询处理的过程，对您编写和优化查询有非常巨大的帮助。</p>
<p>用户向 &lt;&amp;product-name&gt; 发送查询命令和使用其它数据库管理系统完全一样。通过使用客户端应用程序（例如：psql）连接 &lt;&amp;product-name&gt; 主节点，您可以提供 SQL 语句命令。</p>
<p>Parent topic: Querying Data</p>
<h4 id="_3">理解查询优化和查询分发</h4>
<p>主节点负责接收，分析和优化用户查询。最终的执行计划可以是完全并行的，也可以是运行在特定节点的。如图todo对于并行查询计划，主节点将其发送到所有的计算节点上。如图todo所示，对于运行在特定节点的执行计划，主节点将会发送查询计划到一个单独的节点运行。每个计算节点只负责在自己对应的数据上进行相应的数据操作。
query plans</p>
<p>大多数的数据库操作是在所有计算节点并行进行的，例如：扫描数据表，连接运算，聚合运算和排序操作。每个计算节点的操作都不依赖存储在其它计算节点上的数据。</p>
<h1 id="todo-pic">TODO pic</h1>
<p>一些查询可能只访问特定计算节点的数据，例如：单行插入，更新，删除或者是查询操作只涉及表中特定数据（过滤条件正好是表的数据分布键值）。对于上述的查询，查询计划不会发送给所有的计算节点，而是将查询计划发送给该查询影响的节点。</p>
<h1 id="todo-pic_1">TODO pic</h1>
<h4 id="_4">理解查询计划</h4>
<p>查询计划就是 &lt;&amp;product-name&gt; 为了计算查询结果的一系列操作的步骤。查询计划中的每个步骤（节点）代表了一种数据库操作，例如：表扫描，连接运算，聚合运算或者排序操作。查询计划的读取和执行都是自底向上的。</p>
<p>除了常见的操作外，&lt;&amp;product-name&gt; 还支持一些特殊的操作：motion 节点（移动）。移动节点就是查询处理过程中，在不同计算节点直接移动数据。需要注意的是，不是所有的查询都需要数据移动的。例如：运行在特定节点的查询是不需要任何数据移动的。</p>
<p>为了能让查询执行获得最大的并行粒度，&lt;&amp;product-name&gt; 通过将查询计划进行切片来进一步分解任务。每个切片都是可以被一个计算节点独立执行的查询计划子集。当查询计划中包含了数据移动节点时，查询计划就是被分片的。数据移动节点的上下两部分各自是一个独立的分片。</p>
<p>让我们来看下面这个例子：这是一个简单的两张表连接的运算：</p>
<pre><code>SELECT customer, amount
FROM sales JOIN customer USING (cust_id)
WHERE dateCol = '04-30-2008';
</code></pre>
<p>图todo 展示了查询计划。每个计算节点都会收到一份查询计划的拷贝，并且并行进行处理。</p>
<p>这个示例的查询计划包含了一个数据重分布的数据移动节点，该节点用来在不同计算节点直接移动记录使得连接运算得意完成。这里之所有需要数据重分布的节点，是因为 customer 表（用户表）的数据分布是通过 cust_id 来进行的，而 sales 表（销售表）是根据 sale_id 进行的。为了进行连接操作，sales 表的数据需要重新根据 cust_id 来分布。因此查询计划在数据重分布节点两侧被切片，分别是 slice 1 和 slice 2。</p>
<p>这个查询计划还包括了另一种数据移动节点：数据聚合节点。数据聚合节点是为了让所有的计算节点将结果发送给主节点，最后从主节点发送给用户引入的。由于查询计划总是在数据移动节点出现时被切片，这个查询计划还包括了一个隐藏的切片，该切片位于查询的最顶层（slice 3）。并不是所有的查询都包含数据聚合移动节点，例如：CREATE TABLE x AS SELECT ... 语句不需要使用数据聚合移动节点，这是因为数据将会移动到新创建的数据表中，而非主节点。</p>
<h1 id="todo-pic_2">TODO pic</h1>
<h4 id="_5">理解并行查询计划的执行</h4>
<p>&lt;&amp;product-name&gt; 将会创建多个数据库进程来处理查询的相关工作。在主节点上，查询工作进程被称为查询分派器（QD）。QD负责创建和分派查询计划。它同时负责收集和展示最终查询结果。在计算节点上，查询工作进程被称作查询执行起（QE）。QE 
负责执行分配给该进程的查询计划并通过通信模块将中间结果发送给其它工作进程。</p>
<p>每个查询计划的切片都至少会有一个工作进程与之对应负责执行。工作进程会被赋予不会互相依赖的查询计划片段。查询执行的过程中，每个计算节点都会有多个进程并行地参与查询的处理工作。</p>
<p>在不同计算节点上执行相同切片查询计划的工作进程被称为进程组。随着一部分工作的完成，数据记录将会从一个进程组流向其它进程组。这种在数据节点之间的进程间通信被称为互联组件。</p>
<p>图todo 想您展示对于图todo中查询计划在主节点和两个计算节点上的进程分布情况。</p>
<h1 id="todo-pic_3">TODO pic</h1>
<h3 id="_6">查询的定义</h3>
<p>&lt;&amp;product-name&gt; 查询命令是基于 PostgreSQL 开发，而PostgreSQL 是实现了 SQL 标准。</p>
<p>本小结
This topic describes how to construct SQL queries in Greenplum Database.</p>
<ul>
<li>SQL Lexicon</li>
<li>SQL Value Expressions
Parent topic: Querying Data</li>
</ul>
<h4 id="sql-lexicon">SQL Lexicon</h4>
<p>SQL is a standard language for accessing databases. The language consists of elements that enable data storage, retrieval, analysis, viewing, manipulation, and so on. You use SQL commands to construct queries and commands that the Greenplum Database engine understands. SQL queries consist of a sequence of commands. Commands consist of a sequence of valid tokens in correct syntax order, terminated by a semicolon (;).</p>
<p>For more information about SQL commands, see the Greenplum Database Reference Guide.</p>
<p>Greenplum Database uses PostgreSQL's structure and syntax, with some exceptions. For more information about SQL rules and concepts in PostgreSQL, see "SQL Syntax" in the PostgreSQL documentation.</p>
<h4 id="sql">SQL 值表达式</h4>
<p>SQL value expressions consist of one or more values, symbols, operators, SQL functions, and data. The expressions compare data or perform calculations and return a value as the result. 
表达式计算包括：逻辑运算，算数运算和集合运算。</p>
<p>下面列出值表达式的类别：</p>
<ul>
<li>聚合表达式</li>
<li>数组构造表达式</li>
<li>列引用</li>
<li>常亮或字面值</li>
<li>相关自查询</li>
<li>成员选择表达式</li>
<li>函数调用</li>
<li>A new column value in an INSERT or UPDATE</li>
<li>An operator invocation column reference</li>
<li>A positional parameter reference, in the body of a function definition or prepared statement</li>
<li>记录构造表达式</li>
<li>标量子查询</li>
<li>A search condition in a WHERE clause</li>
<li>A target list of a SELECT command</li>
<li>类型转换</li>
<li>括号保护的子表达式</li>
<li>窗口表达式</li>
</ul>
<p>SQL constructs such as functions and operators are expressions but do not follow any general syntax rules. For more information about these constructs, see Using Functions and Operators.</p>
<h5 id="_7">列引用</h5>
<p>列引用的格式如下：</p>
<pre><code>correlation.columnname
</code></pre>
<p>上面的示例中，correlation 是表的名称（也可以使用限定名格式：在表名前面添加模式名）或者定义在 FROM 子句中的表的别名。如果列名在查询访问的表中是唯一的，那么 "correlation." 部分是可以被省略的。</p>
<h5 id="_8">位置参数</h5>
<p>Positional parameters are arguments to SQL statements or functions that you reference by their positions in a series of arguments. For example, $1 refers to the first argument, $2 to the second argument, and so on. The values of positional parameters are set from arguments external to the SQL statement or supplied when SQL functions are invoked. Some client libraries support specifying data values separately from the SQL command, in which case parameters refer to the out-of-line data values. A parameter reference has the form:</p>
<pre><code>$number
</code></pre>
<p>For example:</p>
<pre><code>CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</code></pre>
<p>Here, the $1 references the value of the first function argument whenever the function is invoked.</p>
<h5 id="_9">下标表达式</h5>
<p>If an expression yields a value of an array type, you can extract a specific element of the array value as follows:</p>
<pre><code>expression[subscript]
</code></pre>
<p>You can extract multiple adjacent elements, called an array slice, as follows (including the brackets):</p>
<pre><code>expression[lower_subscript:upper_subscript]
</code></pre>
<p>Each subscript is an expression and yields an integer value.</p>
<p>Array expressions usually must be in parentheses, but you can omit the parentheses when the expression to be subscripted is a column reference or positional parameter. You can concatenate multiple subscripts when the original array is multidimensional. For example (including the parentheses):</p>
<pre><code>mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</code></pre>
<h5 id="_10">成员选择表达式</h5>
<p>如果表达式的值是一个复合类型（例如：记录类型），你可以通过下面的表达式来选择该复合类型中的特定成员值：
If an expression yields a value of a composite type (row type), you can extract a specific field of the row as follows:</p>
<pre><code>expression.fieldname
</code></pre>
<p>The row expression usually must be in parentheses, but you can omit these parentheses when the expression to be selected from is a table reference or positional parameter. For example:</p>
<pre><code>mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</code></pre>
<p>A qualified column reference is a special case of field selection syntax.</p>
<h5 id="_11">运算符调用</h5>
<p>运算符调用支持下面的几种语法：</p>
<pre><code>expression operator expression(binary infix operator)
operator expression(unary prefix operator)
expression operator(unary postfix operator)
</code></pre>
<p>示例中的 operator 实际是运算符符号，例如：AND，OR，+等。运算符也有限定名格式，例如：</p>
<pre><code>OPERATOR(schema.operatorname)
</code></pre>
<p>可以使用的运算符以及他们究竟是一元运算符还是二元运算符，取决于系统和用户的定义。可以参考内建函数和运算符，了解更多信息。</p>
<h5 id="_12">函数调用</h5>
<p>函数调用的语法是函数名（限定名格式：在函数名开头添加模式名）跟随着使用括号保护的参数列表：</p>
<pre><code>function ([expression [, expression ... ]])
</code></pre>
<p>下面示例是通过函数调用计算2的平方根：</p>
<pre><code>sqrt(2)
</code></pre>
<p>参考内建函数和运算符，了解更多信息。</p>
<h5 id="_13">聚集表达式</h5>
<p>An aggregate expression applies an aggregate function across the rows that a query selects. An aggregate function performs a calculation on a set of values and returns a single value, such as the sum or average of the set of values. The syntax of an aggregate expression is one of the following:</p>
<ul>
<li>aggregate_name(expression [ , ... ] ) — operates across all input rows for which the expected result value is non-null. ALL is the default.</li>
<li>aggregate_name(ALL expression [ , ... ] ) — operates identically to the first form because ALL is the default.</li>
<li>aggregate_name(DISTINCT expression [ , ... ] ) — operates across all distinct non-null values of input rows.</li>
<li>aggregate_name(*) — operates on all rows with values both null and non-null. Generally, this form is most useful for the count(*) aggregate function.
Where aggregate_name is a previously defined aggregate (possibly schema-qualified) and expression is any value expression that does not contain an aggregate expression.</li>
</ul>
<p>For example, count(*) yields the total number of input rows, count(f1) yields the number of input rows in which f1 is non-null, and count(distinct f1) yields the number of distinct non-null values of f1.</p>
<p>For predefined aggregate functions, see Built-in Functions and Operators. You can also add custom aggregate functions.</p>
<p>Greenplum Database provides the MEDIAN aggregate function, which returns the fiftieth percentile of the PERCENTILE_CONT result and special aggregate expressions for inverse distribution functions as follows:</p>
<pre><code>PERCENTILE_CONT(_percentage_) WITHIN GROUP (ORDER BY _expression_)
PERCENTILE_DISC(_percentage_) WITHIN GROUP (ORDER BY _expression_)
</code></pre>
<p>Currently you can use only these two expressions with the keyword WITHIN GROUP.</p>
<h5 id="_14">聚合表达式的限制</h5>
<p>The following are current limitations of the aggregate expressions:</p>
<ul>
<li>Greenplum Database does not support the following keywords: ALL, DISTINCT, FILTER and OVER. See Table 5 for more details.</li>
<li>An aggregate expression can appear only in the result list or HAVING clause of a SELECT command. It is forbidden in other clauses, such as WHERE, because those clauses are logically evaluated before the results of aggregates form. This restriction applies to the query level to which the aggregate belongs.</li>
<li>When an aggregate expression appears in a subquery, the aggregate is normally evaluated over the rows of the subquery. If the aggregate's arguments contain only outer-level variables, the aggregate belongs to the nearest such outer level and evaluates over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery in which it appears, and the aggregate expression acts as a constant over any one evaluation of that subquery. See Scalar Subqueries and Table 2.</li>
<li>Greenplum Database does not support DISTINCT with multiple input expressions.</li>
</ul>
<h5 id="window-expressions">Window Expressions</h5>
<p>Window expressions allow application developers to more easily compose complex online analytical processing (OLAP) queries using standard SQL commands. For example, with window expressions, users can calculate moving averages or sums over various intervals, reset aggregations and ranks as selected column values change, and express complex ratios in simple terms.</p>
<p>A window expression represents the application of a window function applied to a window frame, which is defined in a special OVER() clause. A window partition is a set of rows that are grouped together to apply a window function. Unlike aggregate functions, which return a result value for each group of rows, window functions return a result value for every row, but that value is calculated with respect to the rows in a particular window partition. If no partition is specified, the window function is computed over the complete intermediate result set.</p>
<p>The syntax of a window expression is:</p>
<pre><code>window_function ( [expression [, ...]] ) OVER ( window_specification )
</code></pre>
<p>Where window_function is one of the functions listed in Table 3, expression is any value expression that does not contain a window expression, and window_specification is:</p>
<pre><code>[window_name]
[PARTITION BY expression [, ...]]
[[ORDER BY expression [ASC | DESC | USING operator] [, ...]
    [{RANGE | ROWS} 
       { UNBOUNDED PRECEDING
       | expression PRECEDING
       | CURRENT ROW
       | BETWEEN window_frame_bound AND window_frame_bound }]]
</code></pre>
<p>and where window_frame_bound can be one of:</p>
<pre><code>    UNBOUNDED PRECEDING
    expression PRECEDING
    CURRENT ROW
    expression FOLLOWING
    UNBOUNDED FOLLOWING
</code></pre>
<p>A window expression can appear only in the select list of a SELECT command. For example:</p>
<pre><code>SELECT count(*) OVER(PARTITION BY customer_id), * FROM sales;
</code></pre>
<p>The OVER clause differentiates window functions from other aggregate or reporting functions. The OVER clause defines the window_specification to which the window function is applied. A window specification has the following characteristics:</p>
<ul>
<li>The PARTITION BY clause defines the window partitions to which the window function is applied. If omitted, the entire result set is treated as one partition.</li>
<li>
<p>The ORDER BY clause defines the expression(s) for sorting rows within a window partition. The ORDER BY clause of a window specification is separate and distinct from the ORDER BY clause of a regular query expression. The ORDER BY clause is required for the window functions that calculate rankings, as it identifies the measure(s) for the ranking values. For OLAP aggregations, the ORDER BY clause is required to use window frames (the ROWS | RANGE clause).</p>
<p>Note: Columns of data types without a coherent ordering, such as time, are not good candidates for use in the ORDER BY clause of a window specification. Time, with or without a specified time zone, lacks a coherent ordering because addition and subtraction do not have the expected effects. For example, the following is not generally true: x::time &lt; x::time + '2 hour'::interval</p>
</li>
<li>
<p>The ROWS/RANGE clause defines a window frame for aggregate (non-ranking) window functions. A window frame defines a set of rows within a window partition. When a window frame is defined, the window function computes on the contents of this moving frame rather than the fixed contents of the entire window partition. Window frames are row-based (ROWS) or value-based (RANGE).</p>
</li>
</ul>
<h5 id="_15">类型转换</h5>
<p>A type cast specifies a conversion from one data type to another. Greenplum Database accepts two equivalent syntaxes for type casts:</p>
<pre><code>CAST ( expression AS type )
expression::type
</code></pre>
<p>The CAST syntax conforms to SQL; the syntax with :: is historical PostgreSQL usage.</p>
<p>A cast applied to a value expression of a known type is a run-time type conversion. The cast succeeds only if a suitable type conversion function is defined. This differs from the use of casts with constants. A cast applied to a string literal represents the initial assignment of a type to a literal constant value, so it succeeds for any type if the contents of the string literal are acceptable input syntax for the data type.</p>
<p>You can usually omit an explicit type cast if there is no ambiguity about the type a value expression must produce; for example, when it is assigned to a table column, the system automatically applies a type cast. The system applies automatic casting only to casts marked "OK to apply implicitly" in system catalogs. Other casts must be invoked with explicit casting syntax to prevent unexpected conversions from being applied without the user's knowledge.</p>
<h5 id="_16">标量子查询</h5>
<p>A scalar subquery is a SELECT query in parentheses that returns exactly one row with one column. Do not use a SELECT query that returns multiple rows or columns as a scalar subquery. The query runs and uses the returned value in the surrounding value expression. A correlated scalar subquery contains references to the outer query block.</p>
<h5 id="_17">相关子查询</h5>
<p>A correlated subquery (CSQ) is a SELECT query with a WHERE clause or target list that contains references to the parent outer clause. CSQs efficiently express results in terms of results of another query. Greenplum Database supports correlated subqueries that provide compatibility with many existing applications. A CSQ is a scalar or table subquery, depending on whether it returns one or multiple rows. Greenplum Database does not support correlated subqueries with skip-level correlations.</p>
<p>Correlated Subquery Examples
Example 1 – Scalar correlated subquery</p>
<pre><code>SELECT * FROM t1 WHERE t1.x 
            &gt; (SELECT MAX(t2.x) FROM t2 WHERE t2.y = t1.y);
</code></pre>
<p>Example 2 – Correlated EXISTS subquery</p>
<pre><code>SELECT * FROM t1 WHERE 
EXISTS (SELECT 1 FROM t2 WHERE t2.x = t1.x);
</code></pre>
<p>Greenplum Database uses one of the following methods to run CSQs:</p>
<ul>
<li>Unnest the CSQ into join operations – This method is most efficient, and it is how Greenplum Database runs most CSQs, including queries from the TPC-H benchmark.</li>
<li>Run the CSQ on every row of the outer query – This method is relatively inefficient, and it is how Greenplum Database runs queries that contain CSQs in the SELECT list or are connected by OR conditions.
The following examples illustrate how to rewrite some of these types of queries to improve performance.</li>
</ul>
<p>Example 3 - CSQ in the Select List</p>
<p>Original Query</p>
<pre><code>SELECT T1.a,
      (SELECT COUNT(DISTINCT T2.z) FROM t2 WHERE t1.x = t2.y) dt2 
FROM t1;
</code></pre>
<p>Rewrite this query to perform an inner join with t1 first and then perform a left join with t1 again. The rewrite applies for only an equijoin in the correlated condition.</p>
<p>Rewritten Query</p>
<pre><code>SELECT t1.a, dt2 FROM t1 
       LEFT JOIN 
        (SELECT t2.y AS csq_y, COUNT(DISTINCT t2.z) AS dt2 
              FROM t1, t2 WHERE t1.x = t2.y 
              GROUP BY t1.x) 
       ON (t1.x = csq_y);
</code></pre>
<p>Example 4 - CSQs connected by OR Clauses
Original Query</p>
<pre><code>SELECT * FROM t1 
WHERE 
x &gt; (SELECT COUNT(*) FROM t2 WHERE t1.x = t2.x) 
OR x &lt; (SELECT COUNT(*) FROM t3 WHERE t1.y = t3.y)
</code></pre>
<p>Rewrite this query to separate it into two parts with a union on the OR conditions.</p>
<p>Rewritten Query</p>
<pre><code>SELECT * FROM t1 
WHERE x &gt; (SELECT count(*) FROM t2 WHERE t1.x = t2.x) 
UNION 
SELECT * FROM t1 
WHERE x &lt; (SELECT count(*) FROM t3 WHERE t1.y = t3.y)
</code></pre>
<p>To view the query plan, use EXPLAIN SELECT or EXPLAIN ANALYZE SELECT. Subplan nodes in the query plan indicate that the query will run on every row of the outer query, and the query is a candidate for rewriting. For more information about these statements, see Query Profiling.</p>
<h5 id="_18">高级“表”表达式</h5>
<p>Greenplum Database supports table functions with TABLE value expressions. You can sort input rows for advanced table functions with an ORDER BY clause. You can redistribute them with a SCATTER BY clause to specify one or more columns or an expression for which rows with the specified characteristics are available to the same process. This usage is similar to using a DISTRIBUTED BY clause when creating a table, but the redistribution occurs when the query runs.</p>
<p>The following command uses the TABLE function with the SCATTER BY clause in the the GPText function gptext.index() to populate the index mytest.articles with data from the messages table:</p>
<pre><code>SELECT * FROM gptext.index(TABLE(SELECT * FROM messages 
SCATTER BY distrib_id), 'mytest.articles');
</code></pre>
<p>Note:
Based on the distribution of data, Greenplum Database automatically parallelizes table functions with TABLE value parameters over the nodes of the cluster.</p>
<p>For information about the function gptext.index(), see the Pivotal GPText documentation.</p>
<h5 id="_19">数组构造表达式</h5>
<p>An array constructor is an expression that builds an array value from values for its member elements. A simple array constructor consists of the key word ARRAY, a left square bracket [, one or more expressions separated by commas for the array element values, and a right square bracket ]. For example,</p>
<pre><code>SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
</code></pre>
<p>The array element type is the common type of its member expressions, determined using the same rules as for UNION or CASE constructs.</p>
<p>You can build multidimensional array values by nesting array constructors. In the inner constructors, you can omit the keyword ARRAY. For example, the following two SELECT statements produce the same result:</p>
<pre><code>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
</code></pre>
<p>Since multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions.</p>
<p>Multidimensional array constructor elements are not limited to a sub-ARRAY construct; they are anything that produces an array of the proper kind. For example:</p>
<pre><code>CREATE TABLE arr(f1 int[], f2 int[]);
INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], 
ARRAY[[5,6],[7,8]]);
SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
</code></pre>
<p>You can construct an array from the results of a subquery. Write the array constructor with the keyword ARRAY followed by a subquery in parentheses. For example:</p>
<pre><code>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                          ?column?
-----------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}
</code></pre>
<p>The subquery must return a single column. The resulting one-dimensional array has an element for each row in the subquery result, with an element type matching that of the subquery's output column. The subscripts of an array value built with ARRAY always begin with 1.</p>
<h5 id="_20">记录构造表达式</h5>
<p>记录构造器是一种用来从成员值构建记录值的表达式（记录表达式也被称为复合类型）。例如：</p>
<pre><code>SELECT ROW(1,2.5,'this is a test');
</code></pre>
<p>Row constructors have the syntax rowvalue.<em>, which expands to a list of the elements of the row value, as when you use the syntax .</em> at the top level of a SELECT list. For example, if table t has columns f1 and f2, the following queries are the same:</p>
<pre><code>SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</code></pre>
<p>记录构造表达式默认创建的记录值具有匿名记录类型。根据需要，您可以将该值通过类型转换表达式，转换成一个命名复合类型：数据表的记录类型或者If necessary, it can be cast to a named composite type — either the row type of a table, or a composite type created with CREATE TYPE AS. To avoid ambiguity, you can explicitly cast the value if necessary. For example:</p>
<pre><code>CREATE TABLE mytable(f1 int, f2 float, f3 text);
CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' 
LANGUAGE SQL;
</code></pre>
<p>In the following query, you do not need to cast the value because there is only one getf1() function and therefore no ambiguity:</p>
<pre><code>SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT 
$1.f1' LANGUAGE SQL;
</code></pre>
<p>Now we need a cast to indicate which function to call:</p>
<pre><code>SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique
SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS 
myrowtype));
 getf1
-------
    11
</code></pre>
<p>You can use row constructors to build composite values to be stored in a composite-type table column or to be passed to a function that accepts a composite parameter.</p>
<h5 id="_21">表达式求值规则</h5>
<p>The order of evaluation of subexpressions is undefined. The inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</p>
<p>If you can determine the result of an expression by evaluating only some parts of the expression, then other subexpressions might not be evaluated at all. For example, in the following expression:</p>
<pre><code>SELECT true OR somefunc();
</code></pre>
<p>somefunc() would probably not be called at all. The same is true in the following expression:</p>
<pre><code>SELECT somefunc() OR true;
</code></pre>
<p>This is not the same as the left-to-right evaluation order that Boolean operators enforce in some programming languages.</p>
<p>Do not use functions with side effects as part of complex expressions, especially in WHERE and HAVING clauses, because those clauses are extensively reprocessed when developing an execution plan. Boolean expressions (AND/OR/NOT combinations) in those clauses can be reorganized in any manner that Boolean algebra laws allow.</p>
<p>Use a CASE construct to force evaluation order. The following example is an untrustworthy way to avoid division by zero in a WHERE clause:</p>
<pre><code>SELECT ... WHERE x &lt;&gt; 0 AND y/x &gt; 1.5;
</code></pre>
<p>The following example shows a trustworthy evaluation order:</p>
<pre><code>SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</code></pre>
<p>This CASE construct usage defeats optimization attempts; use it only when necessary.</p>
<h3 id="_22">使用函数和运算符</h3>
<p>Greenplum Database evaluates functions and operators used in SQL expressions. Some functions and operators are only allowed to execute on the master since they could lead to inconsistencies in segment databases.</p>
<p>Parent topic: Querying Data</p>
<h4 id="using-functions-in-greenplum-database">Using Functions in Greenplum Database</h4>
<table>
<thead>
<tr>
<th>Function Type</th>
<th>Greenplum Support</th>
<th>Description</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMMUTABLE</td>
<td>Yes</td>
<td>Relies only on information directly in its argument list. Given the same argument values, always returns the same result.</td>
<td></td>
</tr>
<tr>
<td>STABLE</td>
<td>Yes, in most cases</td>
<td>Within a single table scan, returns the same result for same argument values, but results change across SQL statements.</td>
<td>Results depend on database lookups or parameter values. current_timestamp family of functions is STABLE; values do not change within an execution.</td>
</tr>
<tr>
<td>VOLATILE</td>
<td>Restricted</td>
<td>Function values can change within a single table scan. For example: random(), currval(), timeofday().</td>
<td>Any function with side effects is volatile, even if its result is predictable. For example: setval().</td>
</tr>
</tbody>
</table>
<p>In Greenplum Database, data is divided up across segments — each segment is a distinct PostgreSQL database. To prevent inconsistent or unexpected results, do not execute functions classified as VOLATILE at the segment level if they contain SQL commands or modify the database in any way. For example, functions such as setval() are not allowed to execute on distributed data in Greenplum Database because they can cause inconsistent data between segment instances.</p>
<p>To ensure data consistency, you can safely use VOLATILE and STABLE functions in statements that are evaluated on and run from the master. For example, the following statements run on the master (statements without a FROM clause):</p>
<pre><code>SELECT setval('myseq', 201);
SELECT foo();
</code></pre>
<p>If a statement has a FROM clause containing a distributed table and the function in the FROM clause returns a set of rows, the statement can run on the segments:</p>
<pre><code>SELECT * from foo();
</code></pre>
<p>Greenplum Database does not support functions that return a table reference (rangeFuncs) or functions that use the refCursor datatype.</p>
<h4 id="user-defined-functions">User-Defined Functions</h4>
<p>Greenplum Database supports user-defined functions. See Extending SQL in the PostgreSQL documentation for more information.</p>
<p>Use the CREATE FUNCTION statement to register user-defined functions that are used as described in Using Functions in Greenplum Database. By default, user-defined functions are declared as VOLATILE, so if your user-defined function is IMMUTABLE or STABLE, you must specify the correct volatility level when you register your function.</p>
<p>When you create user-defined functions, avoid using fatal errors or destructive calls. Greenplum Database may respond to such errors with a sudden shutdown or restart.</p>
<p>In Greenplum Database, the shared library files for user-created functions must reside in the same library path location on every host in the Greenplum Database array (masters, segments, and mirrors).</p>
<h4 id="built-in-functions-and-operators">Built-in Functions and Operators</h4>
<p>The following table lists the categories of built-in functions and operators supported by PostgreSQL. All functions and operators are supported in Greenplum Database as in PostgreSQL with the exception of STABLE and VOLATILE functions, which are subject to the restrictions noted in Using Functions in Greenplum Database. See the Functions and Operators section of the PostgreSQL documentation for more information about these built-in functions and operators.</p>
<h1 id="todo">TODO</h1>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../sql-ref/" class="btn btn-neutral float-right" title="SQL命令参考">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../management-managing-data/" class="btn btn-neutral" title="数据管理"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../management-managing-data/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../sql-ref/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
