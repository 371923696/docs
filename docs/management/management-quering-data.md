### Querying Data

This topic provides information about using SQL in Greenplum databases.
You enter SQL statements called queries to view, change, and analyze data in a database using the psql interactive SQL client and other client tools.

* About Greenplum Query Processing
* About the Pivotal Query Optimizer
* Defining Queries
* Using Functions and Operators
* Query Performance
* Managing Spill Files Generated by Queries
* Query Profiling

#### About Greenplum Query Processing
This topic provides an overview of how Greenplum Database processes queries. Understanding this process can be useful when writing and tuning queries.

Users issue queries to Greenplum Database as they would to any database management system. They connect to the database instance on the Greenplum master host using a client application such as psql and submit SQL statements.

Parent topic: Querying Data

##### Understanding Query Planning and Dispatch
The master receives, parses, and optimizes the query. The resulting query plan is either parallel or targeted. The master dispatches parallel query plans to all segments, as shown in Figure 1. The master dispatches targeted query plans to a single segment, as shown in Figure 2. Each segment is responsible for executing local database operations on its own set of data.query plans

Most database operations—such as table scans, joins, aggregations, and sorts—execute across all segments in parallel. Each operation is performed on a segment database independent of the data stored in the other segment databases.

# TODO pic

Certain queries may access only data on a single segment, such as single-row INSERT, UPDATE, DELETE, or SELECT operations or queries that filter on the table distribution key column(s). In queries such as these, the query plan is not dispatched to all segments, but is targeted at the segment that contains the affected or relevant row(s).

# TODO pic

#### Understanding Greenplum Query Plans
A query plan is the set of operations Greenplum Database will perform to produce the answer to a query. Each node or step in the plan represents a database operation such as a table scan, join, aggregation, or sort. Plans are read and executed from bottom to top.

In addition to common database operations such as tables scans, joins, and so on, Greenplum Database has an additional operation type called motion. A motion operation involves moving tuples between the segments during query processing. Note that not every query requires a motion. For example, a targeted query plan does not require data to move across the interconnect.

To achieve maximum parallelism during query execution, Greenplum divides the work of the query plan into slices. A slice is a portion of the plan that segments can work on independently. A query plan is sliced wherever a motion operation occurs in the plan, with one slice on each side of the motion.

For example, consider the following simple query involving a join between two tables:

	SELECT customer, amount
	FROM sales JOIN customer USING (cust_id)
	WHERE dateCol = '04-30-2008';
Figure 3 shows the query plan. Each segment receives a copy of the query plan and works on it in parallel.

The query plan for this example has a redistribute motion that moves tuples between the segments to complete the join. The redistribute motion is necessary because the customer table is distributed across the segments by cust_id, but the sales table is distributed across the segments by sale_id. To perform the join, the sales tuples must be redistributed by cust_id. The plan is sliced on either side of the redistribute motion, creating slice 1 and slice 2.

This query plan has another type of motion operation called a gather motion. A gather motion is when the segments send results back up to the master for presentation to the client. Because a query plan is always sliced wherever a motion occurs, this plan also has an implicit slice at the very top of the plan (slice 3). Not all query plans involve a gather motion. For example, a CREATE TABLE x AS SELECT... statement would not have a gather motion because tuples are sent to the newly created table, not to the master.


# TODO pic

#### Understanding Parallel Query Execution
Greenplum creates a number of database processes to handle the work of a query. On the master, the query worker process is called the query dispatcher (QD). The QD is responsible for creating and dispatching the query plan. It also accumulates and presents the final results. On the segments, a query worker process is called a query executor (QE). A QE is responsible for completing its portion of work and communicating its intermediate results to the other worker processes.

There is at least one worker process assigned to each slice of the query plan. A worker process works on its assigned portion of the query plan independently. During query execution, each segment will have a number of processes working on the query in parallel.

Related processes that are working on the same slice of the query plan but on different segments are called gangs. As a portion of work is completed, tuples flow up the query plan from one gang of processes to the next. This inter-process communication between the segments is referred to as the interconnect component of Greenplum Database.

Figure 4 shows the query worker processes on the master and two segment instances for the query plan illustrated in Figure 3.

# TODO pic

#### Defining Queries
Greenplum Database is based on the PostgreSQL implementation of the SQL standard.

This topic describes how to construct SQL queries in Greenplum Database.

* SQL Lexicon
* SQL Value Expressions
Parent topic: Querying Data

##### SQL Lexicon
SQL is a standard language for accessing databases. The language consists of elements that enable data storage, retrieval, analysis, viewing, manipulation, and so on. You use SQL commands to construct queries and commands that the Greenplum Database engine understands. SQL queries consist of a sequence of commands. Commands consist of a sequence of valid tokens in correct syntax order, terminated by a semicolon (;).

For more information about SQL commands, see the Greenplum Database Reference Guide.

Greenplum Database uses PostgreSQL's structure and syntax, with some exceptions. For more information about SQL rules and concepts in PostgreSQL, see "SQL Syntax" in the PostgreSQL documentation.

##### SQL Value Expressions
SQL value expressions consist of one or more values, symbols, operators, SQL functions, and data. The expressions compare data or perform calculations and return a value as the result. Calculations include logical, arithmetic, and set operations.

The following are value expressions:

* An aggregate expression
* An array constructor
* A column reference
* A constant or literal value
* A correlated subquery
* A field selection expression
* A function call
* A new column value in an INSERT or UPDATE
* An operator invocation column reference
* A positional parameter reference, in the body of a function definition or prepared statement
* A row constructor
* A scalar subquery
* A search condition in a WHERE clause
* A target list of a SELECT command
* A type cast
* A value expression in parentheses, useful to group sub-expressions and override precedence
* A window expression
SQL constructs such as functions and operators are expressions but do not follow any general syntax rules. For more information about these constructs, see Using Functions and Operators.

##### Column References
A column reference has the form:

	correlation.columnname
Here, correlation is the name of a table (possibly qualified with a schema name) or an alias for a table defined with a FROM clause or one of the keywords NEW or OLD. NEW and OLD can appear only in rewrite rules, but you can use other correlation names in any SQL statement. If the column name is unique across all tables in the query, you can omit the "correlation." part of the column reference.

##### Positional Parameters
Positional parameters are arguments to SQL statements or functions that you reference by their positions in a series of arguments. For example, $1 refers to the first argument, $2 to the second argument, and so on. The values of positional parameters are set from arguments external to the SQL statement or supplied when SQL functions are invoked. Some client libraries support specifying data values separately from the SQL command, in which case parameters refer to the out-of-line data values. A parameter reference has the form:

	$number
For example:

	CREATE FUNCTION dept(text) RETURNS dept
	    AS $$ SELECT * FROM dept WHERE name = $1 $$
	    LANGUAGE SQL;
Here, the $1 references the value of the first function argument whenever the function is invoked.

##### Subscripts
If an expression yields a value of an array type, you can extract a specific element of the array value as follows:

	expression[subscript]
You can extract multiple adjacent elements, called an array slice, as follows (including the brackets):

	expression[lower_subscript:upper_subscript]
Each subscript is an expression and yields an integer value.

Array expressions usually must be in parentheses, but you can omit the parentheses when the expression to be subscripted is a column reference or positional parameter. You can concatenate multiple subscripts when the original array is multidimensional. For example (including the parentheses):

	mytable.arraycolumn[4]
	mytable.two_d_column[17][34]
	$1[10:42]
	(arrayfunction(a,b))[42]

##### Field Selection
If an expression yields a value of a composite type (row type), you can extract a specific field of the row as follows:

	expression.fieldname
The row expression usually must be in parentheses, but you can omit these parentheses when the expression to be selected from is a table reference or positional parameter. For example:

	mytable.mycolumn
	$1.somecolumn
	(rowfunction(a,b)).col3
A qualified column reference is a special case of field selection syntax.

##### Operator Invocations
Operator invocations have the following possible syntaxes:

	expression operator expression(binary infix operator)
	operator expression(unary prefix operator)
	expression operator(unary postfix operator)
Where operator is an operator token, one of the key words AND, OR, or NOT, or qualified operator name in the form:

	OPERATOR(schema.operatorname)
Available operators and whether they are unary or binary depends on the operators that the system or user defines. For more information about built-in operators, see Built-in Functions and Operators.

##### Function Calls
The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:

	function ([expression [, expression ... ]])
For example, the following function call computes the square root of 2:

	sqrt(2)
See the Greenplum Database Reference Guide for lists of the built-in functions by category. You can add custom functions, too.

##### Aggregate Expressions
An aggregate expression applies an aggregate function across the rows that a query selects. An aggregate function performs a calculation on a set of values and returns a single value, such as the sum or average of the set of values. The syntax of an aggregate expression is one of the following:

* aggregate_name(expression [ , ... ] ) — operates across all input rows for which the expected result value is non-null. ALL is the default.
* aggregate_name(ALL expression [ , ... ] ) — operates identically to the first form because ALL is the default.
* aggregate_name(DISTINCT expression [ , ... ] ) — operates across all distinct non-null values of input rows.
* aggregate_name(*) — operates on all rows with values both null and non-null. Generally, this form is most useful for the count(*) aggregate function.
Where aggregate_name is a previously defined aggregate (possibly schema-qualified) and expression is any value expression that does not contain an aggregate expression.

For example, count(*) yields the total number of input rows, count(f1) yields the number of input rows in which f1 is non-null, and count(distinct f1) yields the number of distinct non-null values of f1.

For predefined aggregate functions, see Built-in Functions and Operators. You can also add custom aggregate functions.

Greenplum Database provides the MEDIAN aggregate function, which returns the fiftieth percentile of the PERCENTILE_CONT result and special aggregate expressions for inverse distribution functions as follows:

	PERCENTILE_CONT(_percentage_) WITHIN GROUP (ORDER BY _expression_)
	PERCENTILE_DISC(_percentage_) WITHIN GROUP (ORDER BY _expression_)
Currently you can use only these two expressions with the keyword WITHIN GROUP.

##### Limitations of Aggregate Expressions

The following are current limitations of the aggregate expressions:

* Greenplum Database does not support the following keywords: ALL, DISTINCT, FILTER and OVER. See Table 5 for more details.
* An aggregate expression can appear only in the result list or HAVING clause of a SELECT command. It is forbidden in other clauses, such as WHERE, because those clauses are logically evaluated before the results of aggregates form. This restriction applies to the query level to which the aggregate belongs.
* When an aggregate expression appears in a subquery, the aggregate is normally evaluated over the rows of the subquery. If the aggregate's arguments contain only outer-level variables, the aggregate belongs to the nearest such outer level and evaluates over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery in which it appears, and the aggregate expression acts as a constant over any one evaluation of that subquery. See Scalar Subqueries and Table 2.
* Greenplum Database does not support DISTINCT with multiple input expressions.

##### Window Expressions
Window expressions allow application developers to more easily compose complex online analytical processing (OLAP) queries using standard SQL commands. For example, with window expressions, users can calculate moving averages or sums over various intervals, reset aggregations and ranks as selected column values change, and express complex ratios in simple terms.

A window expression represents the application of a window function applied to a window frame, which is defined in a special OVER() clause. A window partition is a set of rows that are grouped together to apply a window function. Unlike aggregate functions, which return a result value for each group of rows, window functions return a result value for every row, but that value is calculated with respect to the rows in a particular window partition. If no partition is specified, the window function is computed over the complete intermediate result set.

The syntax of a window expression is:

	window_function ( [expression [, ...]] ) OVER ( window_specification )
Where window_function is one of the functions listed in Table 3, expression is any value expression that does not contain a window expression, and window_specification is:

	[window_name]
	[PARTITION BY expression [, ...]]
	[[ORDER BY expression [ASC | DESC | USING operator] [, ...]
	    [{RANGE | ROWS} 
	       { UNBOUNDED PRECEDING
	       | expression PRECEDING
	       | CURRENT ROW
	       | BETWEEN window_frame_bound AND window_frame_bound }]]

and where window_frame_bound can be one of:

	    UNBOUNDED PRECEDING
	    expression PRECEDING
	    CURRENT ROW
	    expression FOLLOWING
	    UNBOUNDED FOLLOWING

A window expression can appear only in the select list of a SELECT command. For example:

	SELECT count(*) OVER(PARTITION BY customer_id), * FROM sales;
The OVER clause differentiates window functions from other aggregate or reporting functions. The OVER clause defines the window_specification to which the window function is applied. A window specification has the following characteristics:

* The PARTITION BY clause defines the window partitions to which the window function is applied. If omitted, the entire result set is treated as one partition.
* The ORDER BY clause defines the expression(s) for sorting rows within a window partition. The ORDER BY clause of a window specification is separate and distinct from the ORDER BY clause of a regular query expression. The ORDER BY clause is required for the window functions that calculate rankings, as it identifies the measure(s) for the ranking values. For OLAP aggregations, the ORDER BY clause is required to use window frames (the ROWS | RANGE clause).

	Note: Columns of data types without a coherent ordering, such as time, are not good candidates for use in the ORDER BY clause of a window specification. Time, with or without a specified time zone, lacks a coherent ordering because addition and subtraction do not have the expected effects. For example, the following is not generally true: x::time < x::time + '2 hour'::interval

* The ROWS/RANGE clause defines a window frame for aggregate (non-ranking) window functions. A window frame defines a set of rows within a window partition. When a window frame is defined, the window function computes on the contents of this moving frame rather than the fixed contents of the entire window partition. Window frames are row-based (ROWS) or value-based (RANGE).

##### Type Casts
A type cast specifies a conversion from one data type to another. Greenplum Database accepts two equivalent syntaxes for type casts:

	CAST ( expression AS type )
	expression::type
The CAST syntax conforms to SQL; the syntax with :: is historical PostgreSQL usage.

A cast applied to a value expression of a known type is a run-time type conversion. The cast succeeds only if a suitable type conversion function is defined. This differs from the use of casts with constants. A cast applied to a string literal represents the initial assignment of a type to a literal constant value, so it succeeds for any type if the contents of the string literal are acceptable input syntax for the data type.

You can usually omit an explicit type cast if there is no ambiguity about the type a value expression must produce; for example, when it is assigned to a table column, the system automatically applies a type cast. The system applies automatic casting only to casts marked "OK to apply implicitly" in system catalogs. Other casts must be invoked with explicit casting syntax to prevent unexpected conversions from being applied without the user's knowledge.

##### Scalar Subqueries
A scalar subquery is a SELECT query in parentheses that returns exactly one row with one column. Do not use a SELECT query that returns multiple rows or columns as a scalar subquery. The query runs and uses the returned value in the surrounding value expression. A correlated scalar subquery contains references to the outer query block.

##### Correlated Subqueries
A correlated subquery (CSQ) is a SELECT query with a WHERE clause or target list that contains references to the parent outer clause. CSQs efficiently express results in terms of results of another query. Greenplum Database supports correlated subqueries that provide compatibility with many existing applications. A CSQ is a scalar or table subquery, depending on whether it returns one or multiple rows. Greenplum Database does not support correlated subqueries with skip-level correlations.

Correlated Subquery Examples
Example 1 – Scalar correlated subquery

	SELECT * FROM t1 WHERE t1.x 
	            > (SELECT MAX(t2.x) FROM t2 WHERE t2.y = t1.y);
Example 2 – Correlated EXISTS subquery

	SELECT * FROM t1 WHERE 
	EXISTS (SELECT 1 FROM t2 WHERE t2.x = t1.x);
Greenplum Database uses one of the following methods to run CSQs:

* Unnest the CSQ into join operations – This method is most efficient, and it is how Greenplum Database runs most CSQs, including queries from the TPC-H benchmark.
* Run the CSQ on every row of the outer query – This method is relatively inefficient, and it is how Greenplum Database runs queries that contain CSQs in the SELECT list or are connected by OR conditions.
The following examples illustrate how to rewrite some of these types of queries to improve performance.

Example 3 - CSQ in the Select List

Original Query

	SELECT T1.a,
	      (SELECT COUNT(DISTINCT T2.z) FROM t2 WHERE t1.x = t2.y) dt2 
	FROM t1;
Rewrite this query to perform an inner join with t1 first and then perform a left join with t1 again. The rewrite applies for only an equijoin in the correlated condition.

Rewritten Query

	SELECT t1.a, dt2 FROM t1 
	       LEFT JOIN 
	        (SELECT t2.y AS csq_y, COUNT(DISTINCT t2.z) AS dt2 
	              FROM t1, t2 WHERE t1.x = t2.y 
	              GROUP BY t1.x) 
	       ON (t1.x = csq_y);
Example 4 - CSQs connected by OR Clauses
Original Query

	SELECT * FROM t1 
	WHERE 
	x > (SELECT COUNT(*) FROM t2 WHERE t1.x = t2.x) 
	OR x < (SELECT COUNT(*) FROM t3 WHERE t1.y = t3.y)
Rewrite this query to separate it into two parts with a union on the OR conditions.

Rewritten Query

	SELECT * FROM t1 
	WHERE x > (SELECT count(*) FROM t2 WHERE t1.x = t2.x) 
	UNION 
	SELECT * FROM t1 
	WHERE x < (SELECT count(*) FROM t3 WHERE t1.y = t3.y)
To view the query plan, use EXPLAIN SELECT or EXPLAIN ANALYZE SELECT. Subplan nodes in the query plan indicate that the query will run on every row of the outer query, and the query is a candidate for rewriting. For more information about these statements, see Query Profiling.

##### Advanced Table Functions
Greenplum Database supports table functions with TABLE value expressions. You can sort input rows for advanced table functions with an ORDER BY clause. You can redistribute them with a SCATTER BY clause to specify one or more columns or an expression for which rows with the specified characteristics are available to the same process. This usage is similar to using a DISTRIBUTED BY clause when creating a table, but the redistribution occurs when the query runs.

The following command uses the TABLE function with the SCATTER BY clause in the the GPText function gptext.index() to populate the index mytest.articles with data from the messages table:

	SELECT * FROM gptext.index(TABLE(SELECT * FROM messages 
	SCATTER BY distrib_id), 'mytest.articles');
Note:
Based on the distribution of data, Greenplum Database automatically parallelizes table functions with TABLE value parameters over the nodes of the cluster.

For information about the function gptext.index(), see the Pivotal GPText documentation.

##### Array Constructors
An array constructor is an expression that builds an array value from values for its member elements. A simple array constructor consists of the key word ARRAY, a left square bracket [, one or more expressions separated by commas for the array element values, and a right square bracket ]. For example,

	SELECT ARRAY[1,2,3+4];
	  array
	---------
	 {1,2,7}
The array element type is the common type of its member expressions, determined using the same rules as for UNION or CASE constructs.

You can build multidimensional array values by nesting array constructors. In the inner constructors, you can omit the keyword ARRAY. For example, the following two SELECT statements produce the same result:

	SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
	SELECT ARRAY[[1,2],[3,4]];
	     array
	---------------
	 {{1,2},{3,4}}
Since multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions.

Multidimensional array constructor elements are not limited to a sub-ARRAY construct; they are anything that produces an array of the proper kind. For example:

	CREATE TABLE arr(f1 int[], f2 int[]);
	INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], 
	ARRAY[[5,6],[7,8]]);
	SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
	                     array
	------------------------------------------------
	 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
You can construct an array from the results of a subquery. Write the array constructor with the keyword ARRAY followed by a subquery in parentheses. For example:

	SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
	                          ?column?
	-----------------------------------------------------------
	 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}
The subquery must return a single column. The resulting one-dimensional array has an element for each row in the subquery result, with an element type matching that of the subquery's output column. The subscripts of an array value built with ARRAY always begin with 1.

##### Row Constructors
A row constructor is an expression that builds a row value (also called a composite value) from values for its member fields. For example,

	SELECT ROW(1,2.5,'this is a test');
Row constructors have the syntax rowvalue.*, which expands to a list of the elements of the row value, as when you use the syntax .* at the top level of a SELECT list. For example, if table t has columns f1 and f2, the following queries are the same:

	SELECT ROW(t.*, 42) FROM t;
	SELECT ROW(t.f1, t.f2, 42) FROM t;
By default, the value created by a ROW expression has an anonymous record type. If necessary, it can be cast to a named composite type — either the row type of a table, or a composite type created with CREATE TYPE AS. To avoid ambiguity, you can explicitly cast the value if necessary. For example:

	CREATE TABLE mytable(f1 int, f2 float, f3 text);
	CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' 
	LANGUAGE SQL;
In the following query, you do not need to cast the value because there is only one getf1() function and therefore no ambiguity:

	SELECT getf1(ROW(1,2.5,'this is a test'));
	 getf1
	-------
	     1
	CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
	CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT 
	$1.f1' LANGUAGE SQL;
Now we need a cast to indicate which function to call:

	SELECT getf1(ROW(1,2.5,'this is a test'));
	ERROR:  function getf1(record) is not unique
	SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
	 getf1
	-------
	     1
	SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS 
	myrowtype));
	 getf1
	-------
	    11
You can use row constructors to build composite values to be stored in a composite-type table column or to be passed to a function that accepts a composite parameter.

##### Expression Evaluation Rules
The order of evaluation of subexpressions is undefined. The inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.

If you can determine the result of an expression by evaluating only some parts of the expression, then other subexpressions might not be evaluated at all. For example, in the following expression:

	SELECT true OR somefunc();
somefunc() would probably not be called at all. The same is true in the following expression:

	SELECT somefunc() OR true;
This is not the same as the left-to-right evaluation order that Boolean operators enforce in some programming languages.

Do not use functions with side effects as part of complex expressions, especially in WHERE and HAVING clauses, because those clauses are extensively reprocessed when developing an execution plan. Boolean expressions (AND/OR/NOT combinations) in those clauses can be reorganized in any manner that Boolean algebra laws allow.

Use a CASE construct to force evaluation order. The following example is an untrustworthy way to avoid division by zero in a WHERE clause:

	SELECT ... WHERE x <> 0 AND y/x > 1.5;
The following example shows a trustworthy evaluation order:

	SELECT ... WHERE CASE WHEN x <> 0 THEN y/x > 1.5 ELSE false END;
This CASE construct usage defeats optimization attempts; use it only when necessary.

### Using Functions and Operators
Greenplum Database evaluates functions and operators used in SQL expressions. Some functions and operators are only allowed to execute on the master since they could lead to inconsistencies in segment databases.

Parent topic: Querying Data

#### Using Functions in Greenplum Database
| Function Type	| Greenplum Support |	Description |	Comments |
| --- | --- | ---| --- |
| IMMUTABLE |	Yes |	Relies only on information directly in its argument list. Given the same argument values, always returns the same result.	 || 
| STABLE |	Yes, in most cases |	Within a single table scan, returns the same result for same argument values, but results change across SQL statements. |	Results depend on database lookups or parameter values. current_timestamp family of functions is STABLE; values do not change within an execution. |
| VOLATILE |	Restricted |	Function values can change within a single table scan. For example: random(), currval(), timeofday(). |	Any function with side effects is volatile, even if its result is predictable. For example: setval().|

In Greenplum Database, data is divided up across segments — each segment is a distinct PostgreSQL database. To prevent inconsistent or unexpected results, do not execute functions classified as VOLATILE at the segment level if they contain SQL commands or modify the database in any way. For example, functions such as setval() are not allowed to execute on distributed data in Greenplum Database because they can cause inconsistent data between segment instances.

To ensure data consistency, you can safely use VOLATILE and STABLE functions in statements that are evaluated on and run from the master. For example, the following statements run on the master (statements without a FROM clause):

	SELECT setval('myseq', 201);
	SELECT foo();
If a statement has a FROM clause containing a distributed table and the function in the FROM clause returns a set of rows, the statement can run on the segments:

	SELECT * from foo();
Greenplum Database does not support functions that return a table reference (rangeFuncs) or functions that use the refCursor datatype.

#### User-Defined Functions
Greenplum Database supports user-defined functions. See Extending SQL in the PostgreSQL documentation for more information.

Use the CREATE FUNCTION statement to register user-defined functions that are used as described in Using Functions in Greenplum Database. By default, user-defined functions are declared as VOLATILE, so if your user-defined function is IMMUTABLE or STABLE, you must specify the correct volatility level when you register your function.

When you create user-defined functions, avoid using fatal errors or destructive calls. Greenplum Database may respond to such errors with a sudden shutdown or restart.

In Greenplum Database, the shared library files for user-created functions must reside in the same library path location on every host in the Greenplum Database array (masters, segments, and mirrors).

#### Built-in Functions and Operators
The following table lists the categories of built-in functions and operators supported by PostgreSQL. All functions and operators are supported in Greenplum Database as in PostgreSQL with the exception of STABLE and VOLATILE functions, which are subject to the restrictions noted in Using Functions in Greenplum Database. See the Functions and Operators section of the PostgreSQL documentation for more information about these built-in functions and operators.

# TODO